<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>ì¼ë³´ë“œí˜• ìº”ë²„ìŠ¤ â€” í¬ìŠ¤íŠ¸ì‡ ì¹´ë“œ + ë¶„ë¥˜í•˜ê¸°</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;600;800&display=swap" rel="stylesheet">
<style>
  :root{
    --ink:#182233; --muted:#7a8599; --line:#e6e9f2;
    --card:#ffffff; --shadow:0 8px 22px rgba(0,0,0,.08);
    --radius:18px; --gap:14px; --minCell:190px; /* JSì—ì„œ ìë™ ì¡°ì • */
    /* ë„íŠ¸ ë°°ê²½ (ë” í¬ê³  ê·€ì—½ê²Œ) */
    --dotSize:4px; --dotStep:36px;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; color:var(--ink);
    font-family:"Noto Sans KR", system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    -webkit-font-smoothing:antialiased;
    background:
      radial-gradient(circle at 13px 13px, #dfe6fb var(--dotSize), transparent calc(var(--dotSize) + 0.5px)) 0 0/var(--dotStep) var(--dotStep),
      #ffffff;
  }

  /* ìƒë‹¨ ê³ ì • ë°” */
  .topbar{
    position:sticky; top:0; z-index:30; height:60px;
    display:flex; align-items:center; justify-content:flex-end; gap:10px;
    padding:10px 16px; background:linear-gradient(#fff, rgba(255,255,255,.92));
    border-bottom:1px solid var(--line); backdrop-filter:saturate(1.1) blur(4px);
  }
  .btn{
    appearance:none; border:2px solid var(--line); background:#fff; color:#0f172a;
    padding:12px 16px; border-radius:14px; font-weight:800; cursor:pointer;
    box-shadow:0 1px 0 rgba(0,0,0,.02); letter-spacing:.2px; font-size:15px;
    transition:transform .05s ease, border-color .1s ease;
  }
  .btn:active{ transform:translateY(1px) }
  .btn:hover{border-color:#d3d9eb}
  .btn.primary{background:#2f67ff; color:#fff; border-color:#2f67ff}

  .wrap{max-width:1200px; margin:0 auto; padding:18px}
  .grid{
    display:grid; gap:var(--gap);
    grid-template-columns:repeat(auto-fit, minmax(var(--minCell), 1fr));
    align-content:start;
  }

  /* í¬ìŠ¤íŠ¸ì‡ ì¹´ë“œ */
  .card{
    display:flex; flex-direction:column; background:var(--card);
    border:1.5px solid var(--line); border-radius:var(--radius);
    box-shadow:var(--shadow); overflow:hidden;
    touch-action:none; /* ëª¨ë°”ì¼ ë“œë˜ê·¸ ì‹œ ìŠ¤í¬ë¡¤ ë°©ì§€ */
  }
  .shot{ width:100%; aspect-ratio:1/1; position:relative; overflow:hidden; background:#f6f7fb; }
  .shot img{ position:absolute; inset:0; width:100%; height:100%; object-fit:cover; }
  .cap{
    padding:12px 12px; border-top:1px solid var(--line);
    font-size:15px; line-height:1.35; min-height:44px;
    outline:none;
  }
  .cap[contenteditable="true"]:focus{ box-shadow:inset 0 0 0 2px #cfe0ff; border-radius:10px; }

  /* ìµœì´ˆ ë¡œë”© ì•ˆë‚´ (manifest/autoindex ë¶ˆê°€ ì‹œ) */
  .overlay{
    position:fixed; inset:60px 0 0 0; display:flex; align-items:center; justify-content:center;
    pointer-events:auto; z-index:25;
    background:repeating-linear-gradient(45deg, rgba(255,255,255,.92) 0 14px, rgba(255,255,255,.97) 14px 28px);
    border-top:1px dashed #d7dce9;
  }
  .ov-card{
    background:#fff; border:1px solid var(--line); border-radius:16px;
    padding:22px 20px; box-shadow:var(--shadow); text-align:center; max-width:560px;
  }
  .ov-title{font-weight:800; font-size:18px; margin-bottom:8px}
  .ov-desc{color:#64748b; line-height:1.6}
  .ov-actions{margin-top:14px; display:flex; gap:10px; justify-content:center}
  .hide{display:none !important;}

  /* ë¶„ë¥˜ ëª¨ë“œ ë ˆì´ì–´ */
  .classify{
    position:fixed; inset:60px 0 0 0; z-index:22; display:none;
  }
  .classify.active{ display:block; }
  .zone-half{
    position:absolute; top:0; width:50%; height:100%;
    overflow:auto; padding:18px; /* ì‚¬ì§„ ë§ì•„ì§€ë©´ ìŠ¤í¬ë¡¤ ê°€ëŠ¥ */
  }
  /* ì™¼ìª½: ë¹¨ê°• í° ë„íŠ¸ */
  .zone-left{ left:0;
    background:
      radial-gradient(circle at 16px 16px, rgba(244, 63, 94, .28) 6px, transparent 6px) 0 0/44px 44px,
      transparent;
  }
  /* ì˜¤ë¥¸ìª½: íŒŒë‘ í° ë„íŠ¸ */
  .zone-right{ right:0;
    background:
      radial-gradient(circle at 16px 16px, rgba(59, 130, 246, .28) 6px, transparent 6px) 0 0/44px 44px,
      transparent;
  }

  /* ê·€ì—½ê³  êµµì€ ì„¸ë¡œì„  */
  .divider{
    position:absolute; top:0; bottom:0; left:50%; width:18px; transform:translateX(-50%);
    border-radius:18px;
    background:
      radial-gradient(circle, #f97316 5px, transparent 6px) center 14px/1px 40px repeat-y,
      linear-gradient(180deg, #c7d2fe 0%, #f5d0fe 100%);
    box-shadow:inset 0 0 0 2px rgba(0,0,0,.06);
    opacity:.95;
    z-index:26;
    pointer-events:none;
  }

  /* í°, ê·€ì—¬ìš´ ì¡´ íƒ€ì´í‹€(ë²„íŠ¼ ëŠë‚Œ) */
  .zone-title{
    position:sticky; top:0; z-index:2; margin:-8px -8px 12px; padding:12px 16px;
    font-weight:900; font-size:18px;
    border-radius:999px; display:inline-flex; align-items:center; gap:10px;
    color:#0f172a; background:#fff; border:2px solid #e7ecfb; box-shadow:0 6px 14px rgba(0,0,0,.06);
  }
  .zone-left .zone-title::before{ content:"ğŸŒ¿"; font-size:20px }
  .zone-right .zone-title::before{ content:"ğŸ™ï¸"; font-size:20px }

  /* ë¶„ë¥˜ìš© ì¹´ë“œ ê·¸ë¦¬ë“œ */
  .zone-grid{
    display:grid; gap:var(--gap);
    grid-template-columns:repeat(auto-fit, minmax(180px, 1fr));
    padding-top:6px;
  }

  /* ë“œë˜ê·¸ ê³ ìŠ¤íŠ¸ */
  .drag-ghost{
    position:fixed; z-index:40; width:180px; pointer-events:none; opacity:.95;
    transform:translate(-50%, -50%); filter:drop-shadow(0 10px 18px rgba(0,0,0,.18));
  }
  .dragging .card{ opacity:.85 }

  @media (max-width:520px){ :root{ --minCell:160px } }
</style>
</head>
<body>
  <div class="topbar">
    <button id="classifyBtn" class="btn">ğŸ§­ ë¶„ë¥˜í•˜ê¸°</button>
    <button id="shuffle" class="btn">ğŸ”€ ì„ê¸°</button>
  </div>

  <div class="wrap">
    <div id="grid" class="grid" aria-live="polite"></div>
  </div>

  <!-- ë¶„ë¥˜ ëª¨ë“œ ë ˆì´ì–´ -->
  <div id="classify" class="classify" aria-hidden="true">
    <div class="zone-half zone-left">
      <div class="zone-title">ìì—°í™˜ê²½</div>
      <div id="zoneNatural" class="zone-grid"></div>
    </div>
    <div class="divider" aria-hidden="true"></div>
    <div class="zone-half zone-right">
      <div class="zone-title">ì¸ë¬¸í™˜ê²½</div>
      <div id="zoneHuman" class="zone-grid"></div>
    </div>
  </div>

  <!-- í´ë”/íŒŒì¼ ì„ íƒ ì˜¤ë²„ë ˆì´ -->
  <div id="overlay" class="overlay hide">
    <div class="ov-card">
      <div class="ov-title">ì´ë¯¸ì§€ ëª©ë¡ì„ ìë™ìœ¼ë¡œ ê°€ì ¸ì˜¤ì§€ ëª»í–ˆì–´ìš”</div>
      <div class="ov-desc">
        ì„œë²„ì—ì„œ <code>assets/</code> ë””ë ‰í„°ë¦¬ ëª©ë¡ì„ ì—´ëŒí•  ìˆ˜ ì—†ê±°ë‚˜ <code>manifest.json</code>ì´ ì—†ìŠµë‹ˆë‹¤.<br/>
        ì•„ë˜ì—ì„œ í´ë”/íŒŒì¼ì„ ì„ íƒí•˜ë©´ ì¦‰ì‹œ ì¹´ë“œê°€ ë§Œë“¤ì–´ì§‘ë‹ˆë‹¤. (HTTPS í™˜ê²½ì´ë©´ í´ë” ì„ íƒ ê°€ëŠ¥)
      </div>
      <div class="ov-actions">
        <button id="pickDir" class="btn">ğŸ“ í´ë” ì„ íƒ</button>
        <button id="pickFiles" class="btn">ğŸ–¼ï¸ íŒŒì¼ ì„ íƒ</button>
      </div>
    </div>
  </div>

  <!-- ìˆ¨ê¹€ ì…ë ¥ -->
  <input id="fileInput" type="file" webkitdirectory multiple accept="image/*" style="display:none" />
  <input id="multiInput" type="file" multiple accept="image/*" style="display:none" />

<script>
(() => {
  const grid = document.getElementById('grid');
  const shuffleBtn = document.getElementById('shuffle');
  const classifyBtn = document.getElementById('classifyBtn');
  const classifyLayer = document.getElementById('classify');
  const zoneNatural = document.getElementById('zoneNatural');
  const zoneHuman = document.getElementById('zoneHuman');
  const overlay = document.getElementById('overlay');
  const pickDirBtn = document.getElementById('pickDir');
  const pickFilesBtn = document.getElementById('pickFiles');
  const folderInput = document.getElementById('fileInput');
  const filesInput = document.getElementById('multiInput');

  /* ìš°ì„ ìˆœìœ„ë¡œ ì‹œë„í•  ì—”ë“œí¬ì¸íŠ¸ë“¤
     - /assets/list.json  â† (ì•„ë˜ 'ìë™ ìƒì„± ìŠ¤í¬ë¦½íŠ¸'ë¡œ ë§Œë“¤ë©´ ì™„ì „ ìë™)
     - /assets/manifest.json â† ìˆ˜ë™/ìë™ ìƒì„±ë³¸
     - /assets/ (autoindex í—ˆìš© ì„œë²„ì—ì„œë§Œ)
     - ì‹¤íŒ¨ ì‹œ í´ë”/íŒŒì¼ ì„ íƒ UI
  */
  const LIST_JSON_URL = 'assets/list.json';
  const MANIFEST_URL  = 'assets/manifest.json';
  const AUTOINDEX_URL = 'assets/';

  const CAPTION_KEY_PREFIX  = 'jam-note-caption::';
  const CLASSIFY_KEY_PREFIX = 'jam-note-classify::'; // natural/human ì €ì¥

  const $ = (sel, el=document) => el.querySelector(sel);
  const baseName = (p) => (p||'').split('/').pop().replace(/\.[^.]+$/, '');

  let items = []; // { key, src, zone: 'pool'|'natural'|'human' }
  let classifyMode = false;

  function saveZone(key, zone){
    try{ localStorage.setItem(CLASSIFY_KEY_PREFIX + key, zone); }catch{}
  }
  function loadZone(key){
    try{ return localStorage.getItem(CLASSIFY_KEY_PREFIX + key) || 'pool'; }catch{ return 'pool'; }
  }

  function createCardEl(item){
    const savedCap = localStorage.getItem(CAPTION_KEY_PREFIX + item.key);
    const title = savedCap ?? baseName(item.key);

    const card = document.createElement('article');
    card.className = 'card';
    card.dataset.key = item.key;
    card.dataset.zone = item.zone;
    card.innerHTML = `
      <div class="shot"><img src="${item.src}" alt="${title}"></div>
      <div class="cap" contenteditable="true" spellcheck="false"></div>
    `;
    $('.cap', card).textContent = title;

    // ìº¡ì…˜ ì €ì¥
    $('.cap', card).addEventListener('input', (e) => {
      localStorage.setItem(CAPTION_KEY_PREFIX + item.key, e.currentTarget.textContent.trim());
    });

    // ë¶„ë¥˜ ëª¨ë“œì—ì„œ í¬ì¸í„° ë“œë˜ê·¸ (ë°ìŠ¤í¬íƒ‘ + ì•ˆë“œë¡œì´ë“œ)
    enablePointerDrag(card);
    return card;
  }

  function renderGrid(){
    grid.innerHTML = '';
    items.forEach(it => grid.appendChild(createCardEl(it)));
    autosize(grid);
  }
  function renderClassify(){
    zoneNatural.innerHTML = '';
    zoneHuman.innerHTML = '';
    items.forEach(it => {
      const el = createCardEl(it);
      if (it.zone === 'natural') zoneNatural.appendChild(el);
      else if (it.zone === 'human') zoneHuman.appendChild(el);
      else {
        // 'pool'ì€ ë¶„ë¥˜ ëª¨ë“œì—ì„  ì•„ë¬´ ìª½ì—ë„ ë‘ì§€ ì•ŠìŒ(ì‚¬ìš©ìê°€ ëŒì–´ë„£ê²Œ)
      }
    });
    autosize(zoneNatural); autosize(zoneHuman);
  }

  // ì¹´ë“œ ìˆ˜ê°€ ë§ì•„ì§€ë©´ ì…€ í¬ê¸° ìë™ ì¶•ì†Œ
  function autosize(container){
    const n = container.children.length;
    let cell = 200;
    if (n >= 12) cell = 170;
    if (n >= 20) cell = 150;
    if (n >= 28) cell = 130;
    if (n >= 36) cell = 120;
    document.documentElement.style.setProperty('--minCell', cell + 'px');
  }

  // ì„ê¸°
  function shuffleCards(){
    items.sort(() => Math.random() - 0.5);
    classifyMode ? renderClassify() : renderGrid();
  }
  shuffleBtn.addEventListener('click', shuffleCards);

  // ë¶„ë¥˜ ëª¨ë“œ í† ê¸€
  function setClassifyMode(on){
    classifyMode = on;
    if (on){
      classifyLayer.classList.add('active');
      classifyLayer.setAttribute('aria-hidden','false');
      classifyBtn.textContent = 'âœ… ë¶„ë¥˜ ëë‚´ê¸°';
      renderClassify();
    }else{
      classifyLayer.classList.remove('active');
      classifyLayer.setAttribute('aria-hidden','true');
      classifyBtn.textContent = 'ğŸ§­ ë¶„ë¥˜í•˜ê¸°';
      renderGrid();
    }
  }
  classifyBtn.addEventListener('click', () => setClassifyMode(!classifyMode));

  /* ===== Pointer Events ê¸°ë°˜ ì»¤ìŠ¤í…€ ë“œë˜ê·¸ =====
     - ëª¨ë°”ì¼(ì•ˆë“œë¡œì´ë“œ), ë°ìŠ¤í¬íƒ‘ ëª¨ë‘ ì•ˆì •
     - ë“œë¡­ ì¦‰ì‹œ localStorageì— zone ì €ì¥
  */
  function enablePointerDrag(card){
    let dragging = false;
    let ghost = null;
    let pointerId = null;

    card.addEventListener('pointerdown', (e) => {
      if (!classifyMode) return;
      pointerId = e.pointerId;
      dragging = true;
      document.body.classList.add('dragging');
      card.setPointerCapture(pointerId);

      // ê³ ìŠ¤íŠ¸(ë¯¸ë¦¬ë³´ê¸°) ìƒì„±
      const rect = card.getBoundingClientRect();
      ghost = card.cloneNode(true);
      ghost.classList.add('drag-ghost');
      ghost.style.width = Math.min(200, rect.width) + 'px';
      document.body.appendChild(ghost);
      moveGhost(e.clientX, e.clientY);

      e.preventDefault(); // í„°ì¹˜ ìŠ¤í¬ë¡¤ ì–µì œ
    }, {passive:false});

    card.addEventListener('pointermove', (e) => {
      if (!dragging || !ghost) return;
      moveGhost(e.clientX, e.clientY);
      e.preventDefault();
    }, {passive:false});

    card.addEventListener('pointerup', (e) => {
      if (!dragging) return;
      endDrag(e.clientX, e.clientY);
      try{ card.releasePointerCapture(pointerId); }catch{}
      dragging = false; pointerId = null;
      e.preventDefault();
    }, {passive:false});

    card.addEventListener('pointercancel', () => {
      if (ghost){ ghost.remove(); ghost = null; }
      document.body.classList.remove('dragging');
      dragging = false; pointerId = null;
    });

    function moveGhost(x,y){
      ghost.style.left = x + 'px';
      ghost.style.top  = y + 'px';
    }

    function endDrag(x,y){
      if (ghost){ ghost.remove(); ghost = null; }
      document.body.classList.remove('dragging');

      const dropZone = hitTest(x,y);
      const key = card.dataset.key;
      if (!key) return;

      if (dropZone){
        const it = items.find(v => v.key === key);
        if (it){
          it.zone = dropZone;         // ë©”ëª¨ë¦¬ ë°˜ì˜
          saveZone(key, dropZone);    // â˜… ì¦‰ì‹œ ìºì‹œì— ì €ì¥
        }
      }
      // í™”ë©´ ê°±ì‹ 
      if (classifyMode) renderClassify(); else renderGrid();
    }

    function hitTest(x,y){
      const rL = zoneNatural.getBoundingClientRect();
      const rR = zoneHuman.getBoundingClientRect();
      if (x >= rL.left && x <= rL.right && y >= rL.top && y <= rL.bottom) return 'natural';
      if (x >= rR.left && x <= rR.right && y >= rR.top && y <= rR.bottom) return 'human';
      return null;
    }
  }

  /* ===== ë°ì´í„° ë¡œë”© ìˆœì„œ =====
     1) assets/list.json  (ìë™ ìƒì„±ë³¸ ê¶Œì¥)  â†’ ì„±ê³µ ì‹œ ì¢…ë£Œ
     2) assets/manifest.json                â†’ ì„±ê³µ ì‹œ ì¢…ë£Œ
     3) assets/  (autoindexê°€ ì¼œì§„ ì„œë²„ì—ì„œë§Œ) â†’ ì„±ê³µ ì‹œ ì¢…ë£Œ
     4) í´ë”/íŒŒì¼ ì„ íƒ UI
  */
  async function loadAll(){
    if (await tryListJson()) return;
    if (await tryManifest()) return;
    if (await tryAutoindex()) return;
    showOverlay();
  }

  async function tryListJson(){
    try{
      const res = await fetch(LIST_JSON_URL, {cache:'no-store'});
      if(!res.ok) throw 0;
      const data = await res.json();               // {images:["a.jpg", "..."]}
      const files = Array.isArray(data) ? data : (data.images || []);
      if(!files.length) throw 0;
      items = files
        .filter(p => /\.(jpe?g|png|webp|gif)$/i.test(String(p)))
        .map(p => {
          const key = String(p).replace(/^\.?\/*assets\//,'');
          return { key, src: 'assets/' + key, zone: loadZone(key) };
        });
      renderGrid();
      return true;
    }catch{ return false; }
  }

  async function tryManifest(){
    try{
      const res = await fetch(MANIFEST_URL, {cache:'no-store'});
      if(!res.ok) throw 0;
      const data = await res.json();               // ["a.jpg",...] or {images:[...]}
      const files = Array.isArray(data) ? data : (data.images || []);
      if(!files.length) throw 0;
      items = files
        .filter(p => /\.(jpe?g|png|webp|gif)$/i.test(String(p)))
        .map(p => {
          const key = String(p).replace(/^\.?\/*assets\//,'');
          return { key, src: 'assets/' + key, zone: loadZone(key) };
        });
      renderGrid();
      return true;
    }catch{ return false; }
  }

  async function tryAutoindex(){
    try{
      const res = await fetch(AUTOINDEX_URL, {cache:'no-store'});
      if(!res.ok) throw 0;
      const html = await res.text();
      const hrefs = [...html.matchAll(/href="([^"]+\.(?:jpe?g|png|webp|gif))"/gi)].map(m => m[1]);
      const unique = Array.from(new Set(hrefs)).filter(h => !h.endsWith('/'));
      if (!unique.length) throw 0;
      items = unique.map(p => {
        const name = decodeURIComponent(p.split('/').pop());
        return { key: name, src: 'assets/' + name, zone: loadZone(name) };
      });
      renderGrid();
      return true;
    }catch{ return false; }
  }

  /* ===== í´ë”/íŒŒì¼ ì„ íƒ (HTTPS ì›ë³¸ì´ë©´ í´ë” ì„ íƒ ê°€ëŠ¥) ===== */
  function showOverlay(){ overlay.classList.remove('hide'); }
  function hideOverlay(){ overlay.classList.add('hide'); }

  pickDirBtn.addEventListener('click', async () => {
    if (window.showDirectoryPicker){
      try{
        const dir = await window.showDirectoryPicker({id:'assets-picker', mode:'read'});
        const list = [];
        for await (const entry of dir.values()){
          await collectFiles(entry, list);
        }
        if (!list.length) return;
        items = list;
        hideOverlay(); renderGrid();
      }catch{}
      return;
    }
    folderInput.click();
  });
  pickFilesBtn.addEventListener('click', () => filesInput.click());

  async function collectFiles(handle, out){
    if (handle.kind === 'file'){
      const f = await handle.getFile();
      if (!/^image\//.test(f.type)) return;
      const key = f.name;
      out.push({ key, src: URL.createObjectURL(f), zone: loadZone(key) });
    } else if (handle.kind === 'directory'){
      for await (const entry of handle.values()){
        await collectFiles(entry, out);
      }
    }
  }
  folderInput.addEventListener('change', (e) => {
    const files = [...e.target.files].filter(f => /^image\//.test(f.type));
    if (!files.length) return;
    items = files.map(f => ({ key: f.name, src: URL.createObjectURL(f), zone: loadZone(f.name) }));
    hideOverlay(); renderGrid();
  });
  filesInput.addEventListener('change', (e) => {
    const files = [...e.target.files].filter(f => /^image\//.test(f.type));
    if (!files.length) return;
    items = files.map(f => ({ key: f.name, src: URL.createObjectURL(f), zone: loadZone(f.name) }));
    hideOverlay(); renderGrid();
  });

  // ë“œë˜ê·¸&ë“œë¡­ìœ¼ë¡œë„ ì¶”ê°€ ê°€ëŠ¥
  ['dragenter','dragover'].forEach(ev => {
    document.addEventListener(ev, (e) => { e.preventDefault(); }, {passive:false});
  });
  document.addEventListener('drop', async (e) => {
    e.preventDefault();
    const dt = e.dataTransfer;
    if (!dt) return;
    const list = [];
    if (dt.items && dt.items[0] && dt.items[0].webkitGetAsEntry){
      for (const it of dt.items){
        const entry = it.webkitGetAsEntry();
        if (entry) await traverseEntry(entry, list);
      }
    } else if (dt.files){
      for (const f of dt.files){
        if (/^image\//.test(f.type)){
          list.push({ key: f.name, src: URL.createObjectURL(f), zone: loadZone(f.name) });
        }
      }
    }
    if (list.length){
      items = list;
      hideOverlay(); (classifyMode ? renderClassify() : renderGrid());
    }
  });
  async function traverseEntry(entry, out){
    if (entry.isFile){
      await new Promise(res => entry.file(f => {
        if (/^image\//.test(f.type)) out.push({ key: f.name, src: URL.createObjectURL(f), zone: loadZone(f.name) });
        res();
      }));
    } else if (entry.isDirectory){
      const reader = entry.createReader();
      const entries = await new Promise(res => reader.readEntries(res));
      for (const ent of entries){ await traverseEntry(ent, out); }
    }
  }

  // ì‹œì‘
  loadAll();
})();
</script>
</body>
</html>
